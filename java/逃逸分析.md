JVM 的内存布局

- 堆
- 栈
- 本地方法栈
- 方法区
- 程序计数器



都知道实例对象的内存空间是分配在【堆】中的，那是否是所有的实例对象都在【堆】中开辟呢？答案是不一定的

JDK 在 1.6 版本引入逃逸分析



逃逸分析，判断一个对象是否逃逸，说白了就是说对象是否只是在本方法中使用，如果是的话，那么其实实例就不一定需要分配在堆中，就在栈中完成分配即可。因为实例的栈空间在完成一次函数调用之后就被回收了，这样可以提高性能。



```java
public class Test() {
	public static void main(String[] args) {
		while(true) {
			Integer integer = new Integer(1111);
		}
	}
}
```

查看上方代码，正产情况下是一定会产生 【堆溢出】的，但是在使用逃逸分析之后，判断对象没有发生逃逸就直接在栈上完成分配了。这样就不会产生【堆溢出 】



再比如

```java
public static StringBuffer craeteStringBuffer(String s1, String s2) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb;
}
 
public static String createStringBuffer(String s1, String s2) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb.toString();
}
```

第一段代码中的sb就逃逸了，而第二段代码中的sb就没有逃逸。



使用逃逸分析，编译器可以对代码做如下优化：

- 一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。

- 二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。

- 三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。



在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，

`-XX:+DoEscapeAnalysis` ： 表示开启逃逸分析

`-XX:-DoEscapeAnalysis` ： 表示关闭逃逸分析 从 `jdk 1.7` 开始已经默认开始逃逸分析，如需关闭，需要指定 `-XX:-DoEscapeAnalysis`同步省略